---
title: "**Applications of Topology in Networks**"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Part 3

<br>

#### **Scaling TDA on Graphs**


**#2.1	Scalability**

  <span style="color:red"> Research QUESTION:</span>  
  How to Compute PERsistent Homology on large graphs?
  
**#2.2	Motivation: What if the network is too Big?**
  
  <span style="color:red">Complexity</span>
  
  * PH has shown promise in various graph learning applications, but prohibitive computational costs of PH constrain its wider usage. 
  * Most PH studies are limited to small graphs with a few thousand vertices at most. 
  * The complexity of the standard PH algorithm is cubic in the number of simplices [10], so one needs to limit homology computations to 0-th and 1-th levels only
  
  
  <span style="color:red">Large graphs</span>
  
  * Computation of higher-level persistence for relatively large graphs can take days or weeks.


  <span style="color:red">Our approach</span>  
  We aim to address this fundamental bottleneck in the application of TDA to large networks by introducing two new efficient algorithms which significantly reduce the cost of computing persistence diagrams (PD) for large real-world networks:  
	**CoralTDA** and **PrunIT.** 
	
**#2.3	Filtration**

  <span style="color:red">Filtration types</span>  
  * PH in a network setting: power filtration or using different complexes (e.g., Vietoris-Rips, Cech complexes) to construct the filtration for a given filtering function [11]. 
  * We focus on the most common methods to define PH for graphs: sub/superlevel filtrations obtained by a filtering function and the clique (flag) complexes. 
  
  <span style="color:red">Why sub/super level?</span>  
We can inject domain information into the PH process if the chosen filtering function comes from the network domain (e.g., atomic number in protein networks, transaction amount for blockchain networks). 
Our results can be generalized to the persistent homology defined with a filtering function for different complexes. 

**#2.4	Coral Decomposition offers a way (CoralTDA)**

  <span style="color:red">Origins</span> 
  
  * Core decomposition presents a hierarchical ordering of nodes based on edges in communities.

  <span style="color:red">Key idea - CoralTDA</span> 
  
  * The hierarchy can be used to filter-out edges that do not change the topology.
  * (ğ‘˜+1)âˆ’core (i.e., ğº^(ğ‘˜+1)) of a graph G is enough to compute the ğ‘˜^ğ‘¡â„ persistence diagram (PD) of the graph, i.e.,  
        ğ‘ƒğ·_ğ‘˜  (ğº)=ğ‘ƒğ·_ğ‘˜  (ğº^(ğ‘˜+1) ).
  * Core 2 and higher are enough to compute graph loops (i.e., 1-dimensional holes).
  * Core 3 and higher are enough to compute 2-dimensional holes.
  
  <span style="color:red">Illustration - CoralTDA</span> 
  
  * Compute k-core decomposition of nodes,
  * and then select cores to be used

**#2.4	Coral Decomposition offers a way (PrunIT)**

  <span style="color:red">Origins</span>
  
  * In algebraic topology, homotopy is a very effective tool to compute topological invariants like homology.
  * If two spaces are homotopy equivalent, then their corresponding topological invariants are the same, i.e.,
	 ğ‘‹âˆ¼ğ‘Œâ‡’ğ»_ğ‘–  (ğ‘‹)=ğ»_ğ‘–  (ğ‘Œ).
	 
	 
  <span style="color:red">Key idea - PrunIT</span>
  
  * We define dominated vertices in G. We first define the neighborhood  
  of ğ‘¢_0  ğ‘ğ‘  ğ‘(ğ‘¢_0) = {ğ‘¢_0} âˆª {ğ‘£ âˆˆ ğ‘‰ â”¤| ğ‘’_{ğ‘¢_0 ğ‘£}   âˆˆ ğ¸}. 
  * In particular, ğ‘(ğ‘¢_0) âŠ‚ ğ‘‰ is the set of all vertices adjacent to ğ‘¢_0, and ğ‘¢_0 itself.
  * A vertex u is dominated by the vertex v in G if ğ‘(ğ‘¢) âŠ‚ ğ‘(ğ‘£). If there is such a vertex v, we call u a dominated vertex of G
  
  
  <span style="color:red">Example - PrunIT</span>
  
  * Vertex 3 dominates vertices 1 and 2 because all neighbors of 1 or 3 are neighbors of 3. There are no other dominated vertices.
  
**#2.5	Evaluation - Datasets AND LABELS**

 <span style="color:red"> TU Datasets (molecular, chemical, biological)</span>
  
  * Small networks representing molecular, biological shapes
  * From https://chrsmrrs.github.io/datasets/


  <span style="color:red">Single Graphs (citation, social, co-authorship)</span>
  
  * Medium sized: Citeseer, Cora networks
  * Large sized: Youtube, Amazon, DBLP
  
  
  <span style="color:red">Facebook, Twitter ego networks (social)</span>
  
  * Ego networks of users
  
  Stanford Open Graph Benchmark Datasets
  
  * OGBN-ARXIV, OGBN-MAG datasets
  
**#2.5	Evaluation - CoralTDA Reduction in Vertices**

  <span style="color:red">Evaluation</span>
  
  * CoralTDA vertex reduction in graph and node classification datasets (higher is better). Reduction values are averages from graph instances of the datasets (CORA and CITESEER node classification datasets contain a single graph instance only). 
  * FACEBOOK and TWITTER datasets are reduced by 10% for k > 4, whereas in other datasets graphs are reduced to empty sets.
  
**#2.5	Evaluation - PrunIT Reduction in Vertices**

  <span style="color:red">Evaluation</span>
  
  * The figures show reduction percentages by the PrunIT algorithm. FIRSTMM and SYNNEW datasets are reduced by less than 10%; however, the other 11 datasets are reduced by at least 35%.


**2.5	Evaluation - CoralTDa and PrunIT Reduction**

  <span style="color:red">Evaluation</span>
  
  * When we apply both CoralTDA and PrunIt on large networks, even for low cores of 2 and 3, the combined algorithms reach a vertex reduction rate of 78%.

**#2.5	Evaluation - new directions with CoralTDa and PrunIT**

  <span style="color:red">Theory</span>
  
  * By Kahleâ€™s seminal result [12], to observe nontrivial Betti numbers for higher dimensions in ErdÃ³s-RÃ©nyi graphs G(n, p), the average degree must be very high. 
  * For a graph G(n, p), in order to have nontrivial kth-homology in its clique complex, Kahle proved that for ğ‘ = ğ‘›^ğ›¼, Î± should be between âˆ’1/ğ‘˜ and âˆ’1/(ğ‘˜+1).
  * In terms of average degree ğ‘› Ã— ğ‘, this means the average degree should be between ğ‘›^((ğ‘˜âˆ’1)/ğ‘˜)  and ğ‘›^(ğ‘˜/(ğ‘˜+1)). For instance, for dimension k = 2, the average degree should be between âˆšğ‘› and âˆ›(ğ‘›^2 ). 
  
  <span style="color:red">Real world datasets</span>
  
  * For a graph order of n = 1000, this implies that the average degree should be between 31 and 100 to have a nontrivial second homology in random networks. 
  * However, in real-life networks, our results show that higher Betti numbers are prevalent in much sparser graphs.


  

